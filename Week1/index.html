<!DOCTYPE html>
<html>
<head>
<style>
  /* simple tree */
.simple-tree {
  user-select: none;
  -moz-user-select: none;
}
.simple-tree>details>summary {
  display: none;
}
.simple-tree a,
.simple-tree summary {
  display: block;
  width: fit-content;
  width: -moz-fit-content;
  border: solid 1px transparent;
  padding: 0 2px;
  outline: none;
  cursor: pointer;
}
.simple-tree a {
  text-decoration: none;
  color: inherit;
}
.simple-tree ::-webkit-details-marker {
  display: none;
}
.simple-tree summary {
  list-style-type: none;
  background-color: #eee;
  outline: none;
}
.simple-tree.dark summary {
  background-color: #444;
}
.simple-tree details>:not(details),
.simple-tree details {
  position: relative;
}
.simple-tree details :not(summary) {
  margin-left: 20px;
}
.simple-tree.nodots details :not(summary) {
  margin-left: 12px;
}
.simple-tree details::before,
.simple-tree details>:not(details)::before {
  content: '';
  width: 10px;
  display: block;
  position: absolute;
}
.simple-tree details::before,
.simple-tree details>:not(details)::before {
  background: url('data:image/svg+xml;utf8,<svg viewBox="0 0 2 2" xmlns="http://www.w3.org/2000/svg"><g><rect x="0" y="0" width="1" height="1"/></g></svg>') left top / 2px 2px;
}
.simple-tree.dark details::before,
.simple-tree.dark details>:not(summary)::before {
  background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 2 2" xmlns="http://www.w3.org/2000/svg"><g><rect x="0" y="0" width="1" height="1" fill="white"/></g></svg>');
}
.simple-tree.nodots details::before,
.simple-tree.nodots details>:not(summary)::before {
  background-image: none;
}
.simple-tree details::before {
  top: 0;
  height: 100%;
  background-repeat: repeat-y;
  left: 5px;
  z-index: -1;
}
.simple-tree details>:not(details)::before {
  top: 8px;
  height: calc(100% - 8px);
  background-repeat: repeat-x;
  left: -15px;
}
.simple-tree details>summary::before {
  background: url('data:image/svg+xml;utf8,<svg viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg"><g><rect x="0" y="0" width="12" height="12" fill="white" stroke="gray" stroke-width="1"/><line x1="3" y1="6" x2="9" y2="6" stroke="black" stroke-width="2"/><line x1="6" y1="3" x2="6" y2="9" stroke="black" stroke-width="2"/></g></svg>') center center / 12px 12px no-repeat;
  left: -22px;
  top: 2px;
  width: 16px;
  height: 16px;
}
.simple-tree details[open]>summary::before {
  background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 12 12" xmlns="http://www.w3.org/2000/svg"><title/><g><rect x="0" y="0" width="12" height="12" fill="white" stroke="gray" stroke-width="1"/><line x1="3" y1="6" x2="9" y2="6" stroke="black" stroke-width="2"/></g></svg>');
}
/* async tree */
.async-tree details[open][data-loaded=false] {
  pointer-events: none;
}
.async-tree details[open][data-loaded=false]>summary::before {
  background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><g><animateTransform attributeName="transform" type="rotate" from="0 32 32" to="360 32 32" dur="1s" repeatCount="indefinite"/><circle cx="32" cy="32" r="32" fill="whitesmoke"/><path d="M 62 32 A 30 30 0 0 0 32 2" style="stroke: black; stroke-width:6; fill:none;"/></g></svg>');
}
.async-tree.black details[open][data-loaded=false]>summary::before {
  background-image: url('data:image/svg+xml;utf8,<svg viewBox="0 0 64 64" xmlns="http://www.w3.org/2000/svg"><g><animateTransform attributeName="transform" type="rotate" from="0 32 32" to="360 32 32" dur="1s" repeatCount="indefinite"/><circle cx="32" cy="32" r="32" fill="whitesmoke"/><path d="M 62 32 A 30 30 0 0 0 32 2" style="stroke: white; stroke-width:6; fill:none;"/></g></svg>');
}
/* select tree */
.select-tree .selected {
  background-color: #beebff;
  border-color: #99defd;
  z-index: 1;
}

.select-tree.dark .selected {
  background-color: #3a484e;
  border-color: #99defd;
}
</style>
</head>
<body>
  <div id="tree"></div>
<script>
  'use strict';

{
  const Emitter = typeof window.Emitter === 'undefined' ? class Emitter {
    constructor() {
      this.events = {};
    }
    on(name, callback) {
      this.events[name] = this.events[name] || [];
      this.events[name].push(callback);
    }
    once(name, callback) {
      callback.once = true;
      this.on(name, callback);
    }
    emit(name, ...data) {
      if (this.events[name] === undefined ) {
        return;
      }
      for (const c of [...this.events[name]]) {
        c(...data);
        if (c.once) {
          const index = this.events[name].indexOf(c);
          this.events[name].splice(index, 1);
        }
      }
    }
  } : window.Emitter;

  class SimpleTree extends Emitter {
    constructor(parent, properties = {}) {
      super();
      // do not toggle with click
      parent.addEventListener('click', e => {
        // e.clientX to prevent stopping Enter key
        // e.detail to prevent dbl-click
        // e.offsetX to allow plus and minus clicking
        if (e && e.clientX && e.detail === 1 && e.offsetX >= 0) {
          return e.preventDefault();
        }
        const active = this.active();
        if (active && active.dataset.type === SimpleTree.FILE) {
          e.preventDefault();
          this.emit('action', active);
          if (properties['no-focus-on-action'] === true) {
            window.clearTimeout(this.id);
          }
        }
      });
      parent.classList.add('simple-tree');
      if (properties.dark) {
        parent.classList.add('dark');
      }
      this.parent = parent.appendChild(document.createElement('details'));
      this.parent.appendChild(document.createElement('summary'));
      this.parent.open = true;
      // use this function to alter a node before being passed to this.file or this.folder
      this.interrupt = node => node;
    }
    append(element, parent, before, callback = () => {}) {
      if (before) {
        parent.insertBefore(element, before);
      }
      else {
        parent.appendChild(element);
      }
      callback();
      return element;
    }
    file(node, parent = this.parent, before) {
      parent = parent.closest('details');
      node = this.interrupt(node);
      const a = this.append(Object.assign(document.createElement('a'), {
        textContent: node.name,
        href: '#'
      }), parent, before);
      a.dataset.type = SimpleTree.FILE;
      this.emit('created', a, node);
      return a;
    }
    folder(node, parent = this.parent, before) {
      parent = parent.closest('details');
      node = this.interrupt(node);
      const details = document.createElement('details');
      const summary = Object.assign(document.createElement('summary'), {
        textContent: node.name
      });
      details.appendChild(summary);
      this.append(details, parent, before, () => {
        details.open = node.open;
        details.dataset.type = SimpleTree.FOLDER;
      });
      this.emit('created', summary, node);
      return summary;
    }
    open(details) {
      details.open = true;
    }
    hierarchy(element = this.active()) {
      if (this.parent.contains(element)) {
        const list = [];
        while (element !== this.parent) {
          if (element.dataset.type === SimpleTree.FILE) {
            list.push(element);
          }
          else if (element.dataset.type === SimpleTree.FOLDER) {
            list.push(element.querySelector('summary'));
          }
          element = element.parentElement;
        }
        return list;
      }
      else {
        return [];
      }
    }
    siblings(element = this.parent.querySelector('a, details')) {
      if (this.parent.contains(element)) {
        if (element.dataset.type === undefined) {
          element = element.parentElement;
        }
        return [...element.parentElement.children].filter(e => {
          return e.dataset.type === SimpleTree.FILE || e.dataset.type === SimpleTree.FOLDER;
        }).map(e => {
          if (e.dataset.type === SimpleTree.FILE) {
            return e;
          }
          else {
            return e.querySelector('summary');
          }
        });
      }
      else {
        return [];
      }
    }
    children(details) {
      const e = details.querySelector('a, details');
      if (e) {
        return this.siblings(e);
      }
      else {
        return [];
      }
    }
  }
  SimpleTree.FILE = 'file';
  SimpleTree.FOLDER = 'folder';

  class AsyncTree extends SimpleTree {
    constructor(parent, options) {
      super(parent, options);
      // do not allow toggling when folder is loading
      parent.addEventListener('click', e => {
        const details = e.target.parentElement;
        if (details.open && details.dataset.loaded === 'false') {
          e.preventDefault();
        }
      });
      parent.classList.add('async-tree');
    }
    // add open event for folder creation
    folder(...args) {
      const summary = super.folder(...args);
      const details = summary.closest('details');
      details.addEventListener('toggle', e => {
        this.emit(details.dataset.loaded === 'false' && details.open ? 'fetch' : 'open', summary);
      });
      summary.resolve = () => {
        details.dataset.loaded = true;
        this.emit('open', summary);
      };
      return summary;
    }
    asyncFolder(node, parent, before) {
      const summary = this.folder(node, parent, before);
      const details = summary.closest('details');
      details.dataset.loaded = false;

      if (node.open) {
        this.open(details);
      }

      return summary;
    }
    unloadFolder(summary) {
      const details = summary.closest('details');
      details.open = false;
      const focused = this.active();
      if (focused && this.parent.contains(focused)) {
        this.select(details);
      }
      [...details.children].slice(1).forEach(e => e.remove());
      details.dataset.loaded = false;
    }
    browse(validate, es = this.siblings()) {
      for (const e of es) {
        if (validate(e)) {
          this.select(e);
          if (e.dataset.type === SimpleTree.FILE) {
            return this.emit('browse', e);
          }
          const parent = e.closest('details');
          if (parent.open) {
            return this.browse(validate, this.children(parent));
          }
          else {
            window.setTimeout(() => {
              this.once('open', () => this.browse(validate, this.children(parent)));
              this.open(parent);
            }, 0);
            return;
          }
        }
      }
      this.emit('browse', false);
    }
  }

  class SelectTree extends AsyncTree {
    constructor(parent, options = {}) {
      super(parent, options);
      /* multiple clicks outside of elements */
      parent.addEventListener('click', e => {
        if (e.detail > 1) {
          const active = this.active();
          if (active && active !== e.target) {
            if (e.target.tagName === 'A' || e.target.tagName === 'SUMMARY') {
              return this.select(e.target, 'click');
            }
          }
          if (active) {
            this.focus(active);
          }
        }
      });
      window.addEventListener('focus', () => {
        const active = this.active();
        if (active) {
          this.focus(active);
        }
      });
      parent.addEventListener('focusin', e => {
        const active = this.active();
        if (active !== e.target) {
          this.select(e.target, 'focus');
        }
      });
      this.on('created', (element, node) => {
        if (node.selected) {
          this.select(element);
        }
      });
      parent.classList.add('select-tree');
      // navigate
      if (options.navigate) {
        this.parent.addEventListener('keydown', e => {
          const {code} = e;
          if (code === 'ArrowUp' || code === 'ArrowDown') {
            this.navigate(code === 'ArrowUp' ? 'backward' : 'forward');
            e.preventDefault();
          }
        });
      }
    }
    focus(target) {
      window.clearTimeout(this.id);
      this.id = window.setTimeout(() => document.hasFocus() && target.focus(), 100);
    }
    select(target) {
      const summary = target.querySelector('summary');
      if (summary) {
        target = summary;
      }
      [...this.parent.querySelectorAll('.selected')].forEach(e => e.classList.remove('selected'));
      target.classList.add('selected');
      this.focus(target);
      this.emit('select', target);
    }
    active() {
      return this.parent.querySelector('.selected');
    }
    navigate(direction = 'forward') {
      const e = this.active();
      if (e) {
        const list = [...this.parent.querySelectorAll('a, summary')];
        const index = list.indexOf(e);
        const candidates = direction === 'forward' ? list.slice(index + 1) : list.slice(0, index).reverse();
        for (const m of candidates) {
          if (m.getBoundingClientRect().height) {
            return this.select(m);
          }
        }
      }
    }
  }

  class JSONTree extends SelectTree {
    json(array, parent) {
      array.forEach(item => {
        if (item.type === SimpleTree.FOLDER) {
          const folder = this[item.asynced ? 'asyncFolder' : 'folder'](item, parent);
          if (item.children) {
            this.json(item.children, folder);
          }
        }
        else {
          this.file(item, parent);
        }
      });
    }
  }

  window.Tree = JSONTree;
}
</script>
<script>
  /* globals Tree */
'use strict';

var tree = new Tree(document.getElementById('tree'), {
  navigate: true // allow navigate with ArrowUp and ArrowDown
});
tree.on('open', e => console.log('open', e));
tree.on('select', e => console.log('select', e));
tree.on('action', e => console.log('action', e));
tree.on('fetch', e => console.log('fetch', e));
tree.on('browse', e => console.log('browse', e));

var structure = 
[
  {
    name: "Phân tích",
    open: false,
    type: Tree.FOLDER,
    selected: false,
    children:
    [
      {
        name: "Phân tích chức năng",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Xác định các tác nhân hệ thống (tác nhân là phần cứng, người sử dụng, cơ sở dữ liệu, hệ thống khác, ...)",
          },
          {
            name: "Vẽ biểu đổ use case tổng quan",
          },
          {
            name: "Vẽ biểu đồ use case phân rã (nếu cần)",
          },
          {
            name: "Vẽ biểu đồ hoạt động để biểu diễn quy trình nghiệp vụ",
          },
          {
            name: "Đặc tả ca use case, dùng use case descriptions",
          },
          {
            name: "Phân tích một số yêu cầu phi chức năng khác",
            open: false,
            type: Tree.FOLDER,
            selected: false,
            children:
            [
              {
                name: "Thời gian phản hồi (System-response time)",
              },
              {
                name: "Khả năng bảo trì và nâng cấp (Maintainability)",
              },
              {
                name: "Tính dễ dùng (Usability)",
              },
              {
                name: "Độ tin cậy (Reliability)",
              },
              {
                name: "Hiệu năng (Performance/Efficiency)"
              }
            ]
          },
          {
            name: "Ước tính: Phức tạp"
          }
        ]
      },
      {
        name: "Phân tích cấu trúc",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Thẻ CRC",
          },
          {
            name: "Vẽ biểu đồ lớp",
          },
          {
            name: "Ước tính: khá phức tạp"
          }
        ]
      },
      {
        name: "Phân tích hành vi",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Vẽ biểu đồ tuần tự (sequence diagram)",
          },
          {
            name: "Vẽ biểu đồ communication",
          },
          {
            name: "Note: Chỉ sử dụng một trong hai loại biểu đồ"
          },
          {
            name: "Ước tính: khá phức tạp"
          }
        ]
      }
    ]
  },
  {
    name: "Thiết kế",
    open: false,
    type: Tree.FOLDER,
    selected: false,
    children:
    [
      {
        name: "Thiết kế kiến trúc tổng thể của hệ thống",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Vẽ kiến trúc tổng quan của hệ thống, bao gồm các layers: front-end layer (giao diện người dùng), back-end layer (các xử lý nghiệp vụ của hệ thống), data layer (dữ liệu), có thể sử dụng mô hình MVC",
          },
          {
            name: "Ví dụ: Các thành phần của hệ thống bao gồm: client, web browser, server, database server"
          },
          {
            name: "Ước tính: rất đơn giản",
          }
        ]
      },
      {
        name: "Thiết kế chi tiết lớp",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Đặc tả chi tiết các lớp và các hàm",
            open: false,
            type: Tree.FOLDER,
            selected: false,
            children:
            [
              {
                name: "Review kết quả của pha phân tích, thêm các class, phương thức hay thuộc tính cần thiết cũng như bỏ đi những thứ dư thừa (nếu bước phân tích làm tốt thì bước này sẽ tốn ít công sức)",
              },
              {
                name: "Đặt chỉ định truy cập (public/private) cho các thuộc tính và phương thức của mỗi lớp",
              },
              {
                name: "Đặt chữ kí cho từng hàm: tên hàm, kiểu trả về, danh sách tham số",
              },
              {
                name: "Xác định các ràng buộc của mỗi phương thức, hoặc ràng buộc lên đối tượng của một lớp"
              },
              {
                name: "Xử lý ngoại lệ khi ràng buộc bị vi phạm"
              }
            ]
          },
          {
            name: "Xem xét khả năng sử dụng các frameworks, libraries để tăng tính tái sử dụng và giảm bớt công sức cần thực hiện"
          },
          {
            name: "Tái cấu trúc thiết kế",
            open: false,
            type: Tree.FOLDER,
            selected: false,
            children:
            [
              {
                name: "Phân rã các lớp phức tạp thành lớp con đơn giản hơn",
              },
              {
                name: "Chuẩn hóa (đối với các lớp sử dụng để lưu trữ dữ liệu trong cơ sở dữ liệu quan hệ)"
              }
            ]
          },
          {
            name: "Tối ưu thiết kế (tuning)",
            open: false,
            type: Tree.FOLDER,
            selected: false,
            children:
            [
              {
                name: "Đặt lại các thuộc tính trong các lớp (ví dụ: một thuộc tính f của class A có thể nên được đặt ở class B)"
              },
              {
                name: "Lưu các kết quả đã tính toán (có thể sử dụng biến hay thuộc tính) (caching computational results)"
              },
              {
                name: "Tối ưu đường đi của message giữa các objects (ví dụ: nếu message m đi từ object a đến object b thông phải đi qua một số object trung gian, có thể đặt một tham chiếu của b ở trong a để có message có thể đi trực tiếp từ a đến b)"
              },
            ]
          },
          {
            name: "Chuyển thiết kế các lớp từ tổng quát (không phụ thuộc ngôn ngữ lập trình) sang thiết kế cụ thể đối với ngôn ngữ lập trình"
          },
          {
            name: "Ước tính: phức tạp",
          }
        ]
      },
      {
        name: "Thiết kế giao diện",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Giao diện bên trong (internal interface)",
          },
          {
            name: "Giao diện bên ngoài (external interface)",
          },
          {
            name: "Giao diện người dùng (thường chỉ cần có thành phần này)",
          },
          {
            name: "Ước tính: trung bình"
          }
        ]
      },
      {
        name: "Thiết kế dữ liệu",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Vẽ sơ đồ thực thể liên kết",
          },
          {
            name: "Xác định các đối tượng và thông tin cần được lưu trữ trong cơ sở dữ liệu"
          },
          {
            name: "Xác định đặc điểm của dữ liệu (có cấu trúc hay phi cấu trúc)",
          },
          {
            name: "Lựa chọn định dạng lưu trữ",
            open: false,
            type: Tree.FOLDER,
            selected: false,
            children:
            [
              {
                name: "Tệp (tuần tự hoặc ngẫu nhiên)",
              },
              {
                name: "Cơ sở dữ liệu hướng đối tượng (object-oriented database)",
              },
              {
                name: "Cơ sở dữ liệu đối tượng - quan hệ (object-relational database)",
              },
              {
                name: "Cơ sở dữ liệu quan hệ (relational database)"
              }
            ]
          },
          {
            name: "Thiết kế các lớp truy cập và thao tác dữ liệu",
          },
          {
            name: "Ước tính: trung bình"
          }
        ]
      },
      {
        name: "Thiết kế kiến trúc tầng vật lý",
        open: false,
        type: Tree.FOLDER,
        selected: false,
        children:
        [
          {
            name: "Đặc tả phần cứng",
          },
          {
            name: "Đặc tả phần mềm",
          },
          {
            name: "Môi trường triển khai (ví dụ: môi trường mạng)",
          },
          {
            name: "Note: Phần thiết kế này thường được quy định bởi các yêu cầu phi chức năng",
          },
          {
            name: "Ước tính: đơn giản",
          }
        ]
      }
    ]
  }
];

// keep track of the original node objects
tree.on('created', (e, node) => {
  e.node = node;
});
tree.json(structure);
</script>
</body>
</html>
